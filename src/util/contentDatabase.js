// Â© Copyright 2019 Bruno Giorello. Released under GNU AGPLv3, see 'LICENSE.md'.

import Validator from '@/util/contentDatabaseValidator.js';

// A ContentDatabase abstracts concerns like persistence and loading related to
// content data (like spells and rules).
class ContentDatabase {

  constructor(contentJSON, runValidations = true) {
    this.data = getDefaultData();
    this.loadJSON(contentJSON, runValidations);
  }
  // Returns true if the database has at least one spell
  isEmpty() {
    return !this.data.sources.some(s => s.spells.length > 0);
  }
  // Returns an array of all spells contained, sorted alphabetically
  getSpells() {
    const spells = [];
    for (let source of this.data.sources) {
      for (let spell of source.spells) {
        spells.push(spell);
      }
    }
    return spells.sort((a,b) => {
      return a.name < b.name ? -1 : (a.name > b.name ? 1 : 0);
    });
  }
  getRules() {
    const rules = [];
    for (let source of this.data.sources) {
      for (let rule of source.rules) {
        rules.push(rule);
      }
    }
    return rules.sort((a,b) => {
      return a.name < b.name ? -1 : (a.name > b.name ? 1 : 0);
    });
  }
  // Imports a JSON object into the database and persists it
  loadJSON(contentJSON, runValidations = true) {
    if (!contentJSON) {
      throw "Attempted to load an empty JSON into a content database";
    }
    if (runValidations) {
      Validator.validate(contentJSON);
    }
    // Merge the sources in the JSON file with those already present. An existing
    // source is replaced with one in the JSON if the new source has a higher or
    // equal version number.
    for (let newSource of contentJSON.sources) {
      const existingSource = this.data.sources.find(s => s.name == newSource.name);
      if (existingSource) {
        if (existingSource.version > newSource.version) {
          console.log(`Ignoring ${newSource.name} v${newSource.version} because newer version v${existingSource.version} is loaded.`);
        } else {
          // Replace the older source with the updated one
          this.data.sources.splice(this.data.sources.indexOf(existingSource), 1);
          this.addSource(newSource);
        }
      } else {
        this.addSource(newSource);
      }
    }
    this.saveToStorage();
  }
  // Fetch a JSON from a URL and then load it
  loadURL(url, onSuccess, onError = console.error) {
    fetch(url).then(res => res.json()).then(json => {
      try {
        this.loadJSON(json);
        onSuccess();
      } catch (e) {
        onError(e);
      }
    }).catch(error => {
      onError(`Failed to fetch URL. See console for details.`);
      console.error(error);
    });
  }
  // Add a new source to the database
  addSource(source) {
    // Add calculated fields to each spell/rule (redundant info for performance)
    for (let spell of source.spells) {
      spell.downcasedName = spell.name.toLowerCase(); // Used to search
      spell.codename = spell.name.toLowerCase().replace(/\//g, '-').replace(/ /g, '-'); // Used as an identificator for the spell (friendlier to URLs and such)
      spell.source = spell.source || source.name; // If there's a source field, keep it, otherwise use the source name as a default
    }
    for (let rule of source.rules) {
      rule.downcasedName = rule.name.toLowerCase();
      rule.codename = rule.name.toLowerCase().replace(/\//g, '-').replace(/ /g, '-');
      rule.source = rule.source || source.name;
    }
    this.data.sources.push(source);
  }
  // Delete a source from the database
  deleteSource(source) {
    this.data.sources.splice(this.data.sources.indexOf(source), 1);
    this.saveToStorage();
  }
  // Delete all sources from the database
  deleteAllSources() {
    this.data = getDefaultData();
    this.saveToStorage();
  }
  // Persist this database in the browser's LocalStorage
  saveToStorage() {
    try {
      window.localStorage.content = JSON.stringify(this.data);
      return true;
    } catch (ex) {
      throw "Failed to persist content due to the following exception: " + ex.message;
    }
  }
  // Generate a JSON string that can be written into a WLC file
  export() {
    var clonedData = JSON.parse(JSON.stringify(this.data)); // Deep clone the database so that we can modify the copy
    // Remove the autogenerated fields from each spell and rule
    for (let source of clonedData.sources) {
      for (let spell of source.spells) {
        delete spell.downcasedName;
        delete spell.codename;
        if (spell.source == source.name) { // Delete the source name only if it was autogenerated
          delete spell.source;
        }
      }
      for (let rule of source.rules) {
        delete rule.downcasedName;
        delete rule.codename;
        if (rule.source == source.name) {
          delete rule.source;
        }
      }
    }
    return JSON.stringify(clonedData);
  }
  // Get the ContentDatabase persisted in LocalStorage, or if absent/invalid, a default blank one
  static getFromStorageOrDefault() {
    try {
      if (window.localStorage.content) {
        let contentJSON = JSON.parse(window.localStorage.content);
        if (contentJSON.sources) {
          // Load the previously stored local database without running validations
          return new ContentDatabase(contentJSON, false);
        }
      }
    } catch (e) {
      console.error("Couldn't load the local database, using default instead. Reason: " + JSON.stringify(e));
    }
    return this.getDefault();
  }
  // Get a default blank database with no sources
  static getDefault() {
    return new ContentDatabase(getDefaultData());
  }
}
// Get a JSON representing a blank database
function getDefaultData() {
  return {
    format: "WLC",
    formatVersion: "0.2.0",
    sources: []
  }
}

export default ContentDatabase;
